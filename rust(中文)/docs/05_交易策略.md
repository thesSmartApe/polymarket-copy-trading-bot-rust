# 交易策略逻辑

本文档解释了机器人使用的完整交易策略和决策逻辑。

## 目录

1. [概述](#1-概述)
2. [核心策略组件](#2-核心策略组件)
3. [策略参数摘要](#3-策略参数摘要)
4. [详细策略逻辑深入](#4-详细策略逻辑深入)
5. [策略原理](#5-策略原理)
6. [完整策略逻辑流程（伪代码）](#6-完整策略逻辑流程伪代码)
7. [性能考虑](#7-性能考虑)
8. [策略限制](#8-策略限制)
9. [优化技巧](#9-优化技巧)
10. [策略监控和指标](#10-策略监控和指标)
11. [策略调优指南](#11-策略调优指南)
12. [未来增强（潜在）](#12-未来增强潜在)

---

## 1. 概述

机器人实现了**鲸鱼跟单交易策略**，具有智能风险管理、仓位大小和执行优化。该策略旨在：

- 自动复制成功交易者（鲸鱼）
- 通过仓位缩放和安全检查最小化风险
- 通过分层策略优化执行
- 通过风险保护和市场分析保护资本

### 1.1 策略摘要一览

| 组件 | 策略 | 默认值 |
|-----------|----------|---------------|
| **仓位大小** | 鲸鱼规模的 2%，分层倍数 | 2% 基础，4000+ 为 1.25x |
| **价格缓冲** | 按交易规模分层 | 2000+ 为 +0.01，<2000 为 0.00 |
| **订单类型** | 买单 FAK，卖单 GTD | FAK（初始），GTD（最终重试） |
| **风险检查** | 多层安全系统 | 4 层保护 |
| **重新提交** | 分层重试逻辑 | 根据规模 4-5 次尝试 |
| **最小交易** | 跳过低于阈值的交易 | 最小 10 股 |
| **概率** | 小额交易随机执行 | 默认启用 |

### 1.2 策略理念

**核心原则：** 在保持严格风险管理的同时，以缩小规模复制成功交易者。

**关键原则：**
1. **缩小规模：** 永远不要冒超过您能承受的风险（默认 2%）
2. **选择性：** 跳过不符合最低质量阈值的交易
3. **保护资本：** 多层安全检查防止危险交易
4. **优化执行：** 针对不同交易规模使用不同策略
5. **坚持：** 重试逻辑确保最大成交率而不过度支付

## 2. 核心策略组件

### 2.1 交易检测和过滤

**步骤 1：区块链监控**
- 机器人通过 WebSocket 连接到 Polygon 区块链
- 订阅来自 Polymarket 订单簿合约的 `OrdersFilled` 事件
- 按目标鲸鱼地址过滤事件（仅处理您选择的鲸鱼的交易）

**步骤 2：交易验证**
- 验证交易来自目标鲸鱼地址
- 检查交易规模是否满足最小阈值（默认：10 股）
- 验证交易数据完整性（价格、规模、代币 ID）

**步骤 3：初始过滤**
- **跳过条件：**
  - 交易规模 < 最小阈值（防止灰尘订单）
  - 无效的代币 ID 或价格数据
  - 重复交易（相同的交易哈希）

### 2.2 仓位大小策略

**基础缩放：**
- 默认：**鲸鱼仓位规模的 2%**
- 可通过 `SCALING_RATIO` 常量配置（当前为 0.02）

**规模计算公式：**
```
target_size = whale_shares × SCALING_RATIO × size_multiplier
minimum_size = max(MIN_CASH_VALUE / price, MIN_SHARE_COUNT)

if target_size >= minimum_size:
    order_size = target_size
else if USE_PROBABILISTIC_SIZING:
    probability = target_size / minimum_size
    if random() < probability:
        order_size = minimum_size  # 概率执行
    else:
        skip_order  # 概率跳过
else:
    order_size = minimum_size  # 始终执行最小
```

**按层级的规模倍数：**
- **大额交易（4000+ 股）：** 1.25x 倍数
- **中等交易（2000-3999 股）：** 1.0x 倍数
- **小额交易（1000-1999 股）：** 1.0x 倍数
- **非常小的交易（<1000 股）：** 1.0x 倍数

**计算示例：**
```
鲸鱼交易：10,000 股 @ $0.50
基础缩放：10,000 × 0.02 = 200 股
层级倍数（4000+）：200 × 1.25 = 250 股
最终订单：250 股 @ $0.50 = $125
```

### 2.3 价格策略

**价格缓冲逻辑：**
机器人添加价格缓冲以提高成交率，根据交易规模和市场类型而变化：

| 交易规模 | 基础缓冲 | 网球缓冲 | 足球缓冲 | 总缓冲 |
|------------|-------------|---------------|---------------|--------------|
| 4000+      | +0.01       | +0.01（如适用） | +0.01（如适用） | 最多 +0.03 |
| 2000-3999  | +0.01       | +0.01（如适用） | +0.01（如适用） | 最多 +0.03 |
| 1000-1999  | +0.00       | +0.01（如适用） | +0.01（如适用） | 最多 +0.02 |
| <1000      | +0.00       | +0.01（如适用） | +0.01（如适用） | 最多 +0.02 |

**价格计算：**
```rust
if side == BUY:
    limit_price = min(whale_price + buffer, 0.99)
else:  // SELL
    limit_price = max(whale_price - buffer, 0.01)
```

**为什么使用价格缓冲：**
- **大额交易：** 更高的缓冲提高时间敏感交易的成交概率
- **小额交易：** 无缓冲最小化不太紧急交易的滑点成本
- **特殊市场（网球/足球）：** 额外缓冲考虑波动性

### 2.4 执行层级策略

机器人根据交易规模使用**分层执行**以优化不同市场条件：

#### 层级 1：大额交易（4000+ 股）
**策略：** 激进执行
- 价格缓冲：+0.01
- 规模倍数：1.25x（仓位大 25%）
- 订单类型：FAK（立即成交或取消）
- 重新提交尝试：5
- 价格追逐：是（仅首次重试）
- 最大重新提交缓冲：+0.01

**原理：** 大额交易表明强烈信念。更激进的执行最大化敞口，同时缓冲确保成交。

#### 层级 2：中等交易（2000-3999 股）
**策略：** 平衡执行
- 价格缓冲：+0.01
- 规模倍数：1.0x（正常缩放）
- 订单类型：FAK
- 重新提交尝试：4
- 价格追逐：否
- 最大重新提交缓冲：0.00

**原理：** 带适度缓冲的标准执行。无价格追逐防止过度支付。

#### 层级 3：小额交易（1000-1999 股）
**策略：** 保守执行
- 价格缓冲：0.00
- 规模倍数：1.0x
- 订单类型：FAK
- 重新提交尝试：4
- 价格追逐：否
- 最大重新提交缓冲：0.00

**原理：** 小额交易采用保守处理。无缓冲最小化滑点。

#### 层级 4：非常小的交易（<1000 股）
**策略：** 最小执行
- 价格缓冲：0.00
- 规模倍数：1.0x
- 订单类型：FAK
- 重新提交尝试：4
- 价格追逐：否
- 最大重新提交缓冲：0.00

**原理：** 最小敞口，最小滑点。概率大小可能会跳过非常小的交易。

### 2.5 订单类型选择

**FAK（立即成交或取消）订单：**
- 用于：所有买单，大多数重试尝试
- 行为：立即执行或取消（不放在订单簿上）
- 优势：快速执行，无过期订单
- 用例：优先立即执行的时间敏感交易

**GTD（指定日期前有效）订单：**
- 用于：所有卖单，失败买单的最终重试尝试
- 行为：在订单簿上放置带过期时间的订单
- 过期时间：
  - **实时市场：** 61 秒（活跃市场更快过期）
  - **非实时市场：** 1800 秒（30 分钟，更有耐心）
- 优势：允许市场达到您的价格
- 用例：不太紧急的交易，FAK 失败后的最终尝试

**选择逻辑：**
```rust
if side == SELL:
    order_type = GTD  // 所有卖出使用 GTD
else:  // BUY
    if attempt == max_attempts:
        order_type = GTD  // 最终尝试使用 GTD
    else:
        order_type = FAK  // 早期尝试使用 FAK
```

### 2.6 风险管理（熔断器）

机器人实现了**多层风险管理系统**以保护资本：

#### 第 1 层：交易规模过滤
- **最小阈值：** 10 股（可配置）
- **目的：** 过滤灰尘订单和非常小的交易
- **跳过原因：** 费用后负预期价值

#### 第 2 层：序列检测
- **触发：** 短时间内多次大额交易
- **检测窗口：** 30 秒（可配置）
- **触发阈值：** 2 个连续大额交易（可配置）
- **大额交易定义：** >1500 股（可配置）

**逻辑：**
```
if trade_size >= LARGE_TRADE_THRESHOLD:
    add_to_sequence_history(trade)
    
    if count_large_trades_in_window(30s) >= CONSECUTIVE_TRIGGER:
        trigger_book_depth_check()
```

#### 第 3 层：订单簿深度分析
- **触发：** 序列检测后或按需
- **要求：** 鲸鱼价格之外的最小流动性
- **默认阈值：** $200 美元（可配置）
- **检查：** 分析订单簿以确保足够的深度

**深度计算：**
```
if side == BUY:
    check_depth = sum(ask_price × ask_size) where ask_price <= (whale_price + buffer + 0.005)
else:  // SELL
    check_depth = sum(bid_price × bid_size) where bid_price >= (whale_price - buffer - 0.005)

if check_depth < MIN_DEPTH_USD:
    BLOCK_TRADE
```

#### 第 4 层：触发机制
- **触发：** 订单簿获取失败或检测到危险条件
- **操作：** 在指定持续时间内阻止该代币的所有交易
- **默认持续时间：** 120 秒（2 分钟，可配置）
- **恢复：** 持续时间到期后自动重置

**触发条件：**
- 订单簿 API 调用失败
- 检测到操纵模式
- 多次连续深度检查失败

### 2.7 重新提交策略

当订单未能完全成交时，机器人实施智能重新提交：

#### 按层级的重试尝试

**大额交易（4000+ 股）：**
- 最大尝试：**5**
- 尝试 1：价格 +0.01（追逐）
- 尝试 2-5：相同价格（平重试）
- 延迟：无（立即重试）
- 最终尝试：GTD 订单（放在订单簿上）

**小额/中等交易（<4000 股）：**
- 最大尝试：**4**
- 所有尝试：相同价格（无追逐）
- 延迟：尝试之间 50ms（对于 <1000 股）
- 最终尝试：GTD 订单（放在订单簿上）

#### 重新提交流程

```
1. 初始订单下单（FAK）
   ↓
2. 收到订单响应
   ↓
3. 检查成交状态：
   - 完全成交 → 完成
   - 部分成交 → 继续剩余规模
   - 未成交 → 重试
   ↓
4. 重试逻辑：
   - 计算新价格（带/不带增量）
   - 检查价格是否超过最大缓冲
   - 提交重试订单
   ↓
5. 重复直到最大尝试或完全成交
   ↓
6. 最终尝试：GTD 订单（如果未完全成交）
```

#### 价格升级规则

**仅大额交易（4000+ 股）：**
- **尝试 1：** 追逐价格 +0.01（最多到最大缓冲）
- **尝试 2-5：** 相同价格的平重试
- **最大总缓冲：** +0.02（初始 +0.01 + 重新提交 +0.01）

**小额/中等交易：**
- **所有尝试：** 平重试（无价格升级）
- **原理：** 防止在较小交易上过度支付

### 2.8 特定市场调整

#### 网球市场（ATP）
- **额外缓冲：** +0.01
- **检测：** 检查缓存的网球代币列表
- **原理：** 网球市场可能有更高的波动性
- **应用于：** 所有网球市场交易，无论规模大小

#### 足球市场（法甲）
- **额外缓冲：** +0.01
- **检测：** 检查缓存的足球代币列表
- **原理：** 足球市场可能有快速价格变动
- **应用于：** 所有足球市场交易，无论规模大小

#### 实时 vs 非实时市场

**实时市场：**
- **GTD 过期：** 61 秒
- **检测：** 检查市场实时状态缓存
- **原理：** 活跃市场的更快过期防止过期订单

**非实时市场：**
- **GTD 过期：** 1800 秒（30 分钟）
- **原理：** 对非活跃市场更有耐心的方法

### 2.9 执行流程（完整决策树）

```
1. 收到区块链事件
   ↓
2. 验证事件
   ├─ 来自目标鲸鱼？ → 否 → 跳过
   ├─ 有效交易数据？ → 否 → 跳过
   └─ 交易规模 >= 最小？ → 否 → 跳过
   ↓
3. 风险检查（第 1 层）
   ├─ 交易太小？ → 是 → 跳过（SKIPPED_SMALL）
   └─ 继续
   ↓
4. 序列检查（第 2 层）
   ├─ 大额交易？ → 是 → 添加到序列
   ├─ 序列触发？ → 是 → 需要深度检查
   └─ 继续
   ↓
5. 深度检查（第 3 层，如果触发）
   ├─ 获取订单簿
   ├─ 计算价格之外的深度
   ├─ 深度足够？ → 否 → 阻止（RISK_BLOCKED）
   └─ 继续
   ↓
6. 触发检查（第 4 层）
   ├─ 代币触发？ → 是 → 阻止（RISK_BLOCKED: TRIPPED）
   └─ 继续
   ↓
7. 仓位大小
   ├─ 计算基础规模（whale_size × 0.02）
   ├─ 应用层级倍数
   ├─ 检查最小规模要求
   ├─ 概率大小？ → 可能跳过
   └─ 确定最终规模
   ↓
8. 价格计算
   ├─ 从层级获取基础缓冲
   ├─ 添加网球缓冲（如果是网球市场）
   ├─ 添加足球缓冲（如果是足球市场）
   ├─ 计算限价
   └─ 限制在有效范围内（0.01-0.99）
   ↓
9. 订单类型选择
   ├─ 方向 == 卖出？ → 是 → GTD
   ├─ 方向 == 买入？ → 是 → FAK（初始）
   └─ 确定订单类型
   ↓
10. 订单提交
    ├─ 创建签名订单
    ├─ 提交到 Polymarket API
    └─ 接收响应
    ↓
11. 响应处理
    ├─ 成功？ → 检查成交金额
    │   ├─ 完全成交 → 完成
    │   ├─ 部分成交 → 重新提交剩余
    │   └─ 未成交 → 重试逻辑
    └─ 失败？ → 重试逻辑
    ↓
12. 重新提交（如需要）
    ├─ 计算重试价格
    ├─ 检查最大尝试
    ├─ 提交重试订单
    └─ 重复直到成交或最大尝试
    ↓
13. 最终尝试（如果未成交）
    ├─ 切换到 GTD 订单
    ├─ 设置适当的过期时间
    └─ 放在订单簿上
    ↓
14. 日志记录
    ├─ 记录到 CSV 文件
    ├─ 打印到控制台
    └─ 更新统计信息
```

## 3. 策略参数摘要

| 参数 | 默认值 | 描述 |
|-----------|---------------|-------------|
| `SCALING_RATIO` | 0.02 (2%) | 相对于鲸鱼的基础仓位规模 |
| `MIN_WHALE_SHARES_TO_COPY` | 10.0 | 要复制的最小鲸鱼交易规模 |
| `MIN_CASH_VALUE` | $1.01 | 最小订单价值（美元） |
| `MIN_SHARE_COUNT` | 0.0 | 最小股数（通常被现金价值覆盖） |
| `USE_PROBABILISTIC_SIZING` | true | 为小仓位启用概率执行 |
| `PRICE_BUFFER`（默认） | 0.00 | 默认价格缓冲 |
| `CB_LARGE_TRADE_SHARES` | 1500.0 | "大额交易"检测阈值 |
| `CB_CONSECUTIVE_TRIGGER` | 2 | 触发深度检查的大额交易数量 |
| `CB_SEQUENCE_WINDOW_SECS` | 30 | 序列检测的时间窗口 |
| `CB_MIN_DEPTH_USD` | $200.0 | 所需的最小订单簿深度 |
| `CB_TRIP_DURATION_SECS` | 120 | 触发后阻止交易的持续时间 |
| `RESUBMIT_PRICE_INCREMENT` | 0.01 | 重新提交的价格增量 |
| 网球缓冲 | +0.01 | 网球市场的额外缓冲 |
| 足球缓冲 | +0.01 | 足球市场的额外缓冲 |

## 4. 详细策略逻辑深入

### 4.1 仓位大小算法（逐步）

**步骤 1：计算基础目标规模**
```rust
// 来自：src/settings.rs
const SCALING_RATIO: f64 = 0.02;  // 2%

base_target = whale_shares × SCALING_RATIO
// 示例：10,000 股 × 0.02 = 200 股
```

**步骤 2：应用基于层级的大小倍数**
```rust
// 来自：src/settings.rs get_tier_params()
if whale_shares >= 4000.0:
    size_multiplier = 1.25  // 大额交易获得 25% 提升
elif whale_shares >= 2000.0:
    size_multiplier = 1.0   // 中等交易：正常
elif whale_shares >= 1000.0:
    size_multiplier = 1.0   // 小额交易：正常
else:
    size_multiplier = 1.0   // 非常小：正常

scaled_target = base_target × size_multiplier
// 示例：200 股 × 1.25 = 250 股（对于 4000+ 层级）
```

**步骤 3：计算最小所需规模**
```rust
// 来自：src/main.rs calculate_safe_size()
const MIN_CASH_VALUE: f64 = 1.01;  // 最小 $1.01 订单价值
const MIN_SHARE_COUNT: f64 = 0.0;  // 通常被现金价值覆盖

minimum_size = max(MIN_CASH_VALUE / price, MIN_SHARE_COUNT)
// 示例：max(1.01 / 0.50, 0.0) = max(2.02, 0.0) = 2.02 股
```

**步骤 4：概率执行检查**
```rust
// 来自：src/main.rs calculate_safe_size()
const USE_PROBABILISTIC_SIZING: bool = true;

if scaled_target >= minimum_size:
    return (scaled_target, SizeType::Scaled)  // 完全执行
    
else if USE_PROBABILISTIC_SIZING:
    probability = scaled_target / minimum_size
    // 示例：1.5 股 / 2.02 股 = 0.743 (74.3%)
    
    if random() < probability:
        return (minimum_size, SizeType::ProbHit(74))  // 执行
    else:
        return (0.0, SizeType::ProbSkip(74))  // 跳过
        
else:
    return (minimum_size, SizeType::Scaled)  // 始终执行最小
```

**完整示例 1（大额交易 - 完全执行）：**
```
鲸鱼交易：10,000 股 @ $0.50

步骤 1：base_target = 10,000 × 0.02 = 200 股
步骤 2：size_multiplier = 1.25（4000+ 层级）
        scaled_target = 200 × 1.25 = 250 股
步骤 3：minimum_size = max(1.01 / 0.50, 0.0) = 2.02 股
步骤 4：250 >= 2.02 → 执行完整规模（SCALED）
        
最终订单：250 股 @ $0.50 = $125 美元
```

**完整示例 2（小额交易 - 概率执行）：**
```
鲸鱼交易：50 股 @ $0.60

步骤 1：base_target = 50 × 0.02 = 1.0 股
步骤 2：size_multiplier = 1.0（低于 1000 层级）
        scaled_target = 1.0 × 1.0 = 1.0 股
步骤 3：minimum_size = max(1.01 / 0.60, 0.0) = 1.68 股
步骤 4：1.0 < 1.68 → 概率大小
        
        概率 = 1.0 / 1.68 = 0.595 (59.5%)
        随机值 = 0.42（例如）
        
        由于 0.42 < 0.595：
        → 以最小规模执行
        
最终订单：1.68 股 @ $0.60 = $1.01 美元（PROB_HIT 60%）
```

**完整示例 3（非常小的交易 - 概率跳过）：**
```
鲸鱼交易：30 股 @ $0.70

步骤 1：base_target = 30 × 0.02 = 0.6 股
步骤 2：size_multiplier = 1.0
        scaled_target = 0.6 × 1.0 = 0.6 股
步骤 3：minimum_size = max(1.01 / 0.70, 0.0) = 1.44 股
步骤 4：0.6 < 1.44 → 概率大小
        
        概率 = 0.6 / 1.44 = 0.417 (41.7%)
        随机值 = 0.65（例如）
        
        由于 0.65 >= 0.417：
        → 跳过交易（PROB_SKIP 42%）
        
结果：未下单（交易太小，无法证明最小订单成本合理）
```

**为什么使用概率大小？**

概率大小系统防止负预期价值交易，同时仍允许偶尔参与非常小的鲸鱼交易。

**数学原理：**
- 非常小的仓位（<$1.01）的费用成本会超过其价值
- 但完全跳过所有小额交易意味着错过一些机会
- 解决方案：根据其规模相对于最小值的概率执行小额交易

**预期价值计算：**
```
EV = (概率 × 利润) - 费用

没有概率大小：
- 始终执行最小：EV = 利润 - 费用（通常为负）
- 始终跳过：EV = 0（错过机会）

有概率大小：
- 以概率执行：EV = (概率 × 利润) - (概率 × 费用)
- 这确保 EV 平均为非负
```

### 4.2 价格计算逻辑（详细）

**步骤 1：从层级确定基础缓冲**
```rust
// 来自：src/settings.rs get_tier_params()
if whale_shares >= 4000.0:
    base_buffer = 0.01  // 大额：+0.01 缓冲
elif whale_shares >= 2000.0:
    base_buffer = 0.01  // 中等：+0.01 缓冲
elif whale_shares >= 1000.0:
    base_buffer = 0.00  // 小额：无缓冲
else:
    base_buffer = 0.00  // 非常小：无缓冲
```

**步骤 2：添加特定运动缓冲**
```rust
// 来自：src/settings.rs get_tier_params()
tennis_buffer = tennis_markets::get_tennis_token_buffer(token_id)  // 如果是网球则为 +0.01
soccer_buffer = soccer_markets::get_soccer_token_buffer(token_id)  // 如果是足球则为 +0.01

total_buffer = base_buffer + tennis_buffer + soccer_buffer
```

**步骤 3：计算限价**
```rust
// 来自：src/main.rs process_order()
if side_is_buy:
    limit_price = min(whale_price + total_buffer, 0.99)  // 上限为 0.99
else:  // SELL
    limit_price = max(whale_price - total_buffer, 0.01)  // 下限为 0.01
```

**完整示例：**
```
鲸鱼交易：买入 5,000 股 @ $0.55（网球市场）

步骤 1：base_buffer = 0.01（4000+ 层级）
步骤 2：tennis_buffer = 0.01（检测到网球市场）
        total_buffer = 0.01 + 0.01 = 0.02
步骤 3：limit_price = min(0.55 + 0.02, 0.99) = 0.57
        
最终限价：$0.57（比鲸鱼的 $0.55 高 0.02）
```

### 4.3 风险保护（熔断器）逻辑（详细）

**第 1 层：快速路径检查**
```rust
// 来自：src/risk_guard.rs check_fast()
pub fn check_fast(&mut self, token_id: &str, shares: f64) -> SafetyEvaluation {
    // 检查代币是否当前触发
    if let Some(tripped_until) = self.tokens.get(token_id)
        .and_then(|state| state.tripped_until) {
        if Instant::now() < tripped_until {
            return SafetyEvaluation {
                decision: SafetyDecision::Block,
                reason: SafetyReason::Tripped { secs_left: ... },
                consecutive_large: 0,
            };
        }
    }
    
    // 检查交易是否足够大以触发序列检查
    if shares < self.config.large_trade_shares {  // 默认：1500.0
        return SafetyEvaluation {
            decision: SafetyDecision::Allow,
            reason: SafetyReason::SmallTrade,
            consecutive_large: 0,
        };
    }
    
    // 添加到序列历史
    self.add_to_sequence(token_id, shares);
    
    // 在窗口内计算连续大额交易
    let count = self.count_in_window(token_id, self.config.sequence_window);  // 30秒
    
    if count >= self.config.consecutive_trigger {  // 默认：2
        return SafetyEvaluation {
            decision: SafetyDecision::FetchBook,
            reason: SafetyReason::SeqNeedBook { count },
            consecutive_large: count,
        };
    }
    
    SafetyEvaluation {
        decision: SafetyDecision::Allow,
        reason: SafetyReason::SeqOk { count },
        consecutive_large: count,
    }
}
```

**第 2 层：订单簿深度检查**
```rust
// 来自：src/risk_guard.rs check_with_book()
pub fn check_with_book(
    &mut self, 
    token_id: &str, 
    consecutive_count: u8, 
    depth_usd: f64
) -> SafetyEvaluation {
    if depth_usd < self.config.min_depth_beyond_usd {  // 默认：$200
        // 触发代币（阻止一段时间）
        self.trip(token_id);
        
        SafetyEvaluation {
            decision: SafetyDecision::Block,
            reason: SafetyReason::Trap { 
                seq: consecutive_count, 
                depth_usd: depth_usd as u16 
            },
            consecutive_large: consecutive_count,
        }
    } else {
        SafetyEvaluation {
            decision: SafetyDecision::Allow,
            reason: SafetyReason::DepthOk { 
                seq: consecutive_count, 
                depth_usd: depth_usd as u16 
            },
            consecutive_large: consecutive_count,
        }
    }
}
```

**深度计算：**
```rust
// 来自：src/risk_guard.rs calc_liquidity_depth()
pub fn calc_liquidity_depth(
    side: TradeSide, 
    levels: &[(f64, f64)],  // (价格, 规模) 元组
    threshold: f64
) -> f64 {
    // 为安全边际调整阈值 0.5%
    let threshold_adj = if side == TradeSide::Buy {
        threshold * 1.005  // 买入：检查略高于
    } else {
        threshold * 0.995  // 卖出：检查略低于
    };
    
    let mut total_usd = 0.0;
    for &(price, size) in levels {
        let beyond = if side == TradeSide::Buy {
            price > threshold_adj  // 卖单高于阈值
        } else {
            price < threshold_adj  // 买单低于阈值
        };
        
        if beyond {
            total_usd += price * size;  // 添加美元价值
        }
    }
    
    total_usd
}
```

**风险检查流程示例：**
```
事件：鲸鱼以 $0.50 买入 2,000 股

步骤 1：check_fast()
  - shares (2000) >= large_trade_threshold (1500) ✓
  - 添加到序列历史
  - 30 秒窗口内计数：2 笔交易
  - 2 >= consecutive_trigger (2) ✓
  → 决策：FetchBook（需要深度检查）
  
步骤 2：获取订单簿
  - 获取价格 > $0.50 的卖单
  - 计算深度：$450 美元
  
步骤 3：check_with_book()
  - depth ($450) >= min_depth ($200) ✓
  → 决策：允许（交易通过）
```

### 4.4 重新提交逻辑（详细算法）

**初始订单提交：**
```rust
// 来自：src/main.rs process_order()
// 首次尝试：FAK 订单
let args = OrderArgs {
    token_id: token_id,
    price: limit_price,
    size: calculated_size,
    side: "BUY",
    order_type: Some("FAK".to_string()),
    ...
};

let response = client.post_order_fast(body, creds)?;

// 解析响应
if response.status().is_success() {
    let order_resp: OrderResponse = serde_json::from_str(&response.text())?;
    let filled_shares: f64 = order_resp.taking_amount.parse().unwrap_or(0.0);
    
    if filled_shares < requested_size {
        // 部分成交 → 重新提交剩余
        let remaining = requested_size - filled_shares;
        if remaining >= minimum_threshold {
            send_resubmit_request(...);
        }
    }
}
```

**重新提交价格升级：**
```rust
// 来自：src/main.rs resubmit_worker()
fn calculate_resubmit_price(
    whale_shares: f64,
    attempt: u8,
    current_price: f64,
    max_price: f64
) -> f64 {
    // 仅大额交易（4000+）在首次尝试时追逐
    let should_chase = if whale_shares >= 4000.0 {
        attempt == 1  // 仅尝试 1
    } else {
        false  // 从不追逐
    };
    
    let increment = if should_chase {
        RESUBMIT_PRICE_INCREMENT  // +0.01
    } else {
        0.0  // 平重试
    };
    
    let new_price = current_price + increment;
    
    // 不超过最大缓冲
    if new_price > max_price {
        return max_price;  // 上限为最大
    }
    
    new_price
}
```

**重新提交尝试流程：**
```rust
// 来自：src/main.rs resubmit_worker()
let max_attempts = if whale_shares >= 4000.0 { 5 } else { 4 };

for attempt in 1..=max_attempts {
    let is_last = attempt == max_attempts;
    
    // 计算价格
    let price = calculate_resubmit_price(...);
    
    // 提交订单
    let (success, body, filled) = submit_resubmit_order(...);
    
    if success {
        if is_last {
            // GTD 订单已下单（可能稍后成交）
            return "GTD_SUBMITTED";
        } else {
            // FAK 订单：检查成交
            if filled >= remaining_size {
                return "FULLY_FILLED";
            } else {
                // 部分成交：继续剩余
                remaining_size -= filled;
                continue;
            }
        }
    } else {
        // 失败：如果不是最后一次尝试则重试
        if !is_last {
            if whale_shares < 1000.0 {
                sleep(50ms);  // 小额交易：延迟
            }
            continue;
        } else {
            return "FAILED";
        }
    }
}
```

**完整重新提交示例：**
```
初始订单：250 股 @ $0.57（FAK）
结果：部分成交（150 股成交，100 股剩余）

尝试 1（FAK，价格 +0.01）：
  价格：$0.58（4000+ 层级追逐 +0.01）
  结果：失败（未成交）
  延迟：无（大额交易）
  
尝试 2（FAK，相同价格）：
  价格：$0.58（平重试）
  结果：成交 50 股
  剩余：50 股
  
尝试 3（FAK，相同价格）：
  价格：$0.58（平重试）
  结果：成交 30 股
  剩余：20 股
  
尝试 4（FAK，相同价格）：
  价格：$0.58（平重试）
  结果：失败
  
尝试 5（GTD，相同价格）：
  价格：$0.58
  类型：GTD（如果是实时市场则在 61 秒后过期）
  结果：订单已放在订单簿上（可能稍后成交）
  
总成交：230/250 股（92%）
```

### 4.5 市场检测和缓存系统

**缓存结构：**
```rust
// 来自：src/market_cache.rs
pub struct MarketCaches {
    pub neg_risk: RwLock<FxHashMap<String, bool>>,      // 代币 → neg_risk 标志
    pub slugs: RwLock<FxHashMap<String, String>>,       // 代币 → 市场 slug
    pub tennis_tokens: RwLock<FxHashMap<String, String>>, // 代币 → 类别
    pub soccer_tokens: RwLock<FxHashMap<String, ()>>,   // 代币 → 标记
    pub live_status: RwLock<FxHashMap<String, bool>>,   // 代币 → is_live
}
```

**缓存查找流程：**
```rust
// 步骤 1：检查代币是否是网球市场
pub fn get_tennis_token_buffer(token_id: &str) -> f64 {
    global_caches().tennis_tokens.read()
        .map(|cache| {
            if cache.contains_key(token_id) {
                0.01  // 网球市场获得 +0.01 缓冲
            } else {
                0.0   // 不是网球市场
            }
        })
        .unwrap_or(0.0)
}

// 步骤 2：检查实时状态以确定 GTD 过期
pub fn get_is_live(token_id: &str) -> Option<bool> {
    global_caches().live_status.read()
        .ok()?
        .get(token_id)
        .copied()
}

// 步骤 3：使用实时状态确定过期时间
pub fn get_gtd_expiry_secs(is_live: bool) -> u64 {
    if is_live {
        61      // 实时：快速过期（1 分钟）
    } else {
        1800    // 非实时：有耐心（30 分钟）
    }
}
```

## 5. 策略原理

### 5.1 为什么使用 2% 缩放？
- **风险管理：** 限制敞口同时保持有意义的仓位规模
- **资本效率：** 允许复制账户大得多的鲸鱼
- **实用性：** 大多数用户可以舒适地以 2% 规模交易
- **数学性：** 2% 在参与和风险之间提供了良好的平衡

### 5.2 为什么使用分层执行？
- **规模重要：** 更大的交易表明更强的信念 → 更激进
- **成本优化：** 较小的交易不需要激进执行 → 节省滑点
- **成交率优化：** 不同策略针对不同交易规模优化
- **市场影响：** 分层方法最小化市场影响同时最大化成交

### 5.3 为什么使用价格缓冲？
- **成交率：** 提高订单执行概率
- **时间敏感性：** 大额交易通常是时间敏感的 → 缓冲值得
- **市场影响：** 小缓冲最小化市场影响同时确保成交
- **统计优势：** 支付的小额溢价被更高的成交概率抵消

### 5.4 为什么使用风险保护系统？
- **保护：** 防止在操纵或低流动性期间复制
- **自动化：** 无需手动干预
- **自适应：** 条件正常化后自动重置
- **多层：** 多次检查捕获不同类型的风险

### 5.5 为什么使用重新提交？
- **市场条件：** 订单簿快速变化 → 重试捕获更好的价格
- **部分成交：** 在波动市场中常见 → 重新提交剩余规模
- **分层方法：** 针对不同交易规模使用不同策略
- **持久性：** 最终 GTD 尝试允许市场达到您的价格

### 5.6 概率大小说明

**目的：**
当计算的仓位规模低于所需的最小订单规模（$1.01）时，防止负预期价值交易。

**何时触发：**
- 当 `scaled_target < minimum_size`
- 仅当 `USE_PROBABILISTIC_SIZING = true`（默认：true）

**工作原理：**
1. 计算概率：`p = scaled_target / minimum_size`
2. 生成随机数：`r = random() ∈ [0, 1)`
3. 如果 `r < p`：以 `minimum_size` 执行（PROB_HIT）
4. 如果 `r >= p`：跳过交易（PROB_SKIP）

**示例场景：**

**场景 A：60% 概率**
```
scaled_target = 0.6 股
minimum_size = 1.0 股
probability = 0.6 / 1.0 = 0.6 (60%)

结果：60% 机会执行 1.0 股，40% 机会跳过
```

**场景 B：80% 概率**
```
scaled_target = 0.8 股  
minimum_size = 1.0 股
probability = 0.8 / 1.0 = 0.8 (80%)

结果：80% 机会执行 1.0 股，20% 机会跳过
```

**场景 C：20% 概率**
```
scaled_target = 0.2 股
minimum_size = 1.0 股
probability = 0.2 / 1.0 = 0.2 (20%)

结果：20% 机会执行 1.0 股，80% 机会跳过
```

**为什么这有效：**
- 确保多次交易的预期订单规模 = `scaled_target`
- 防止在微小交易上持续亏损
- 仍允许偶尔参与小额鲸鱼交易
- 在避免灰尘订单的同时保持风险状况

## 6. 完整策略逻辑流程（伪代码）

### 6.1 主执行循环

```rust
// 主机器人循环（简化）
loop {
    // 1. 通过 WebSocket 接收区块链事件
    event = receive_blockchain_event();
    
    // 2. 解析和验证事件
    if !is_valid_event(event) { continue; }
    if !is_from_target_whale(event) { continue; }
    
    parsed_event = parse_event(event);
    
    // 3. 异步处理订单
    spawn(handle_event(parsed_event));
}
```

### 6.2 事件处理流程

```rust
async fn handle_event(event: ParsedEvent) {
    // 步骤 1：获取市场信息
    is_live = market_cache::get_is_live(&event.token_id);
    
    // 步骤 2：提交订单
    status = order_engine.submit(event, is_live).await;
    
    // 步骤 3：记录结果
    log_to_csv(event, status);
    print_console(event, status);
}
```

### 6.3 订单处理逻辑

```rust
fn process_order(order_info: &OrderInfo) -> String {
    // 过滤器 1：跳过禁用的交易
    if !enable_trading { return "SKIPPED_DISABLED"; }
    if mock_trading { return "MOCK_ONLY"; }
    
    // 过滤器 2：最小交易规模
    if order_info.shares < MIN_WHALE_SHARES_TO_COPY {
        return "SKIPPED_SMALL";
    }
    
    // 风险检查 1：快速路径（不获取订单簿）
    let eval = risk_guard.check_fast(&token_id, shares);
    
    match eval.decision {
        SafetyDecision::Block => return "RISK_BLOCKED";
        SafetyDecision::FetchBook => {
            // 风险检查 2：获取订单簿并检查深度
            let depth = fetch_book_depth(...);
            let final_eval = risk_guard.check_with_book(...);
            if final_eval.decision == SafetyDecision::Block {
                return "RISK_BLOCKED";
            }
        }
        SafetyDecision::Allow => {}
    }
    
    // 计算：仓位规模
    let (buffer, order_type, size_multiplier) = get_tier_params(shares, is_buy, token_id);
    let (my_shares, size_type) = calculate_safe_size(shares, price, size_multiplier);
    
    if my_shares == 0.0 {
        return "SKIPPED_PROBABILITY";
    }
    
    // 计算：限价
    let limit_price = if is_buy {
        min(whale_price + buffer, 0.99)
    } else {
        max(whale_price - buffer, 0.01)
    };
    
    // 提交：创建并提交订单
    let order = create_order(token_id, limit_price, my_shares, order_type);
    let response = submit_order(order);
    
    // 处理：处理响应
    if response.success {
        if response.filled < my_shares {
            // 部分成交 → 重新提交剩余
            schedule_resubmit(...);
        }
        return format!("SUCCESS: {} filled", response.filled);
    } else {
        // 失败 → 安排重新提交
        schedule_resubmit(...);
        return "RESUBMITTING";
    }
}
```

### 6.4 决策树可视化

```
开始：收到区块链事件
│
├─ [来自目标鲸鱼？]
│  ├─ 否 → 跳过（忽略事件）
│  └─ 是 → 继续
│
├─ [有效交易数据？]
│  ├─ 否 → 跳过（无效数据）
│  └─ 是 → 继续
│
├─ [交易规模 >= 最小？]
│  ├─ 否 → 跳过（SKIPPED_SMALL）
│  └─ 是 → 继续
│
├─ 风险检查第 1 层：快速检查
│  ├─ 代币触发？ → 是 → 阻止（RISK_BLOCKED: TRIPPED）
│  ├─ 交易太小？ → 是 → 允许（快速路径）
│  └─ 大额交易？ → 是 → 检查序列
│     │
│     ├─ [序列触发？（30 秒内 2+ 大额交易）]
│     │  ├─ 是 → 获取订单簿进行深度检查
│     │  └─ 否 → 允许（继续）
│
├─ 风险检查第 2 层：深度检查（如果触发）
│  ├─ 获取订单簿
│  ├─ 计算流动性深度
│  ├─ [深度 >= $200？]
│  │  ├─ 否 → 阻止（RISK_BLOCKED: INSUFFICIENT_DEPTH）
│  │  └─ 是 → 允许（继续）
│
├─ 仓位大小
│  ├─ 计算基础：whale_shares × 0.02
│  ├─ 应用层级倍数
│  ├─ 检查最小规模要求
│  ├─ [需要概率大小？]
│  │  ├─ 是 → 随机决策（可能跳过）
│  │  └─ 否 → 使用计算的规模
│
├─ 价格计算
│  ├─ 从层级获取基础缓冲
│  ├─ 添加网球缓冲（如果是网球市场）
│  ├─ 添加足球缓冲（如果是足球市场）
│  └─ 计算限价（限制在 0.01-0.99）
│
├─ 订单类型选择
│  ├─ [是卖出？]
│  │  ├─ 是 → GTD 订单
│  │  └─ 否 → FAK 订单（对于买入）
│
├─ 订单提交
│  ├─ 创建签名订单
│  ├─ 提交到 Polymarket API
│  └─ 接收响应
│
├─ 响应处理
│  ├─ [成功？]
│  │  ├─ 是 → 检查成交金额
│  │  │  ├─ 完全成交 → 完成 ✅
│  │  │  ├─ 部分成交 → 重新提交剩余
│  │  │  └─ 未成交 → 安排重试
│  │  └─ 否 → 安排重试
│
├─ 重新提交循环（如需要）
│  ├─ 计算重试价格（带/不带增量）
│  ├─ 检查最大尝试
│  ├─ 提交重试订单
│  └─ 重复直到成交或最大尝试
│
└─ 最终尝试（如果未成交）
   ├─ 切换到 GTD 订单
   ├─ 设置过期时间（实时 61 秒 / 非实时 1800 秒）
   └─ 放在订单簿上
```

### 6.5 策略参数及其影响

**仓位大小参数：**

| 参数 | 值 | 增加时的影响 | 减少时的影响 |
|-----------|-------|---------------------|---------------------|
| `SCALING_RATIO` | 0.02 (2%) | 更多敞口，更高风险 | 更少敞口，更低风险 |
| `MIN_WHALE_SHARES_TO_COPY` | 10.0 | 更少交易，更大平均规模 | 更多交易，更小平均规模 |
| `MIN_CASH_VALUE` | $1.01 | 过滤更多小额交易 | 允许更多小额交易 |
| 规模倍数（4000+ 层级） | 1.25x | 大额交易上更大的仓位 | 大额交易上更小的仓位 |

**价格缓冲参数：**

| 参数 | 值 | 增加时的影响 | 减少时的影响 |
|-----------|-------|---------------------|---------------------|
| 基础缓冲（4000+ 层级） | +0.01 | 更高成交率，更多滑点 | 更低成交率，更少滑点 |
| 基础缓冲（2000-3999） | +0.01 | 更高成交率，更多滑点 | 更低成交率，更少滑点 |
| 网球缓冲 | +0.01 | 网球上更好的成交，更多成本 | 网球上更差的成交，更少成本 |
| 足球缓冲 | +0.01 | 足球上更好的成交，更多成本 | 足球上更差的成交，更少成本 |

**风险管理参数：**

| 参数 | 值 | 增加时的影响 | 减少时的影响 |
|-----------|-------|---------------------|---------------------|
| `CB_LARGE_TRADE_SHARES` | 1500.0 | 检测到更少大额交易 | 检测到更多大额交易 |
| `CB_CONSECUTIVE_TRIGGER` | 2 | 不太敏感（更多交易通过） | 更敏感（更少交易通过） |
| `CB_SEQUENCE_WINDOW_SECS` | 30 | 更长窗口（不太敏感） | 更短窗口（更敏感） |
| `CB_MIN_DEPTH_USD` | $200.0 | 更保守（更少交易） | 不太保守（更多交易） |
| `CB_TRIP_DURATION_SECS` | 120 | 更长阻止（更保守） | 更短阻止（不太保守） |

## 7. 性能考虑

### 7.1 延迟优化

**WebSocket 连接：**
- 实时事件监控（亚秒级检测）
- 失败时自动重连
- 心跳/保持活动机制

**并行处理：**
- 订单提交不阻塞事件监控
- 可以并发处理多个订单
- 用于非阻塞 I/O 的异步/等待架构

**缓存系统：**
- 缓存市场数据以避免 API 延迟
- 定期刷新（每 30 分钟）
- 用于零分配查找的线程本地存储

### 7.2 执行速度

**订单类型：**
- **FAK 订单：** 立即执行或取消（<100ms）
- **GTD 订单：** 放在订单簿上（不等待立即执行）

**优化路径：**
- 针对不同场景的不同代码路径
- 热路径优化（最小分配）
- 快速失败路径（可能时跳过检查）

**重试延迟：**
- 大额交易：立即重试（无延迟）
- 小额交易（<1000 股）：重试之间延迟 50ms
- 原理：小额交易受益于订单簿刷新时间

### 7.3 资源使用

**内存：**
- 线程本地缓冲区（避免堆分配）
- 缓存数据结构（有界大小）
- 高效数据结构（FxHashMap 用于速度）

**CPU：**
- 最小解析开销
- 高效的十六进制/JSON 解析
- 优化的热路径

**网络：**
- 连接池（HTTP 客户端）
- 缓存的 API 响应
- 最小化 API 调用

## 8. 策略限制

### 8.1 策略不做什么

- ❌ **市场分析：** 无预测或市场研究
- ❌ **投资组合管理：** 无仓位再平衡
- ❌ **止损/止盈：** 无自动退出订单
- ❌ **仓位监控：** 成交后无跟踪
- ❌ **退出策略：** 您手动管理平仓
- ❌ **多鲸鱼：** 一次只复制一个鲸鱼
- ❌ **做市：** 不是做市策略
- ❌ **套利：** 无跨市场套利

### 8.2 已知限制

**鲸鱼依赖性：**
- 策略有效性完全取决于鲸鱼质量
- 如果鲸鱼停止交易或表现不佳，机器人会反映这一点
- 无独立市场分析来验证交易

**市场条件：**
- 在高度波动条件下可能表现不佳
- 跟单交易本质上滞后（总是落后于鲸鱼）
- 可能在低流动性市场中挣扎

**执行限制：**
- 预期会有一些滑点（特别是大额交易）
- 某些订单的成交率 <100%
- 时间延迟（总是略微落后于鲸鱼）

**资本要求：**
- 需要足够的资本用于 2% 缩放仓位
- 必须维持 gas 费用（MATIC）余额
- 大额鲸鱼交易可能需要大量资本

## 9. 优化技巧

### 9.1 提高成交率

**监控和调整：**
- 在 CSV 日志中跟踪成交率
- 监控鲸鱼的典型交易规模
- 如果持续错过成交，调整 `SCALING_RATIO`
- 考虑为特定市场增加价格缓冲

**鲸鱼选择：**
- 选择交易规模一致的鲸鱼
- 避免交易非常大仓位的鲸鱼（可能超过您的资本）
- 随时间监控鲸鱼的成功率

### 9.2 降低滑点

**价格缓冲优化：**
- 如果滑点很高，减少小额交易的价格缓冲
- 在 CSV 日志中监控执行质量
- 如需要，调整层级阈值
- 考虑在高成交量市场中减少缓冲

**层级调整：**
- 如需要，微调层级边界
- 根据您的风险承受能力调整规模倍数
- 按层级监控平均滑点

### 9.3 风险管理

**保守方法：**
- 增加熔断器阈值
- 增加 `CB_MIN_DEPTH_USD` 以更严格的流动性要求
- 增加 `CB_CONSECUTIVE_TRIGGER` 以降低敏感性
- 减少 `SCALING_RATIO` 以降低敞口

**监控：**
- 在日志中监控熔断器触发
- 跟踪被阻止交易的原因
- 根据您的风险状况调整参数
- 定期查看 CSV 日志以寻找模式

## 10. 策略监控和指标

### 10.1 要跟踪的关键指标

**执行指标：**
- **成交率：** 完全成交的订单百分比
  - 目标：>80% 完全成交
  - 跟踪：部分成交 vs 完全成交
  
- **平均滑点：** 预期成交价格与实际成交价格之间的差异
  - 计算：`(actual_price - limit_price) / limit_price`
  - 按层级和市场类型跟踪

- **执行时间：** 从检测到成交的时间
  - 测量：事件时间戳 → 成交时间戳
  - 目标：平均 <2 秒

**风险指标：**
- **熔断器触发：** 频率和原因
  - 跟踪：交易被阻止的频率和原因
  - 监控：TRIPPED、INSUFFICIENT_DEPTH 等

- **重新提交率：** 订单需要重试的频率
  - 跟踪：需要重新提交的订单百分比
  - 监控：所需的平均尝试次数

**性能指标：**
- **执行的总交易数：** 时间段内的计数
- **总成交量：** 所有交易的美元价值
- **平均交易规模：** 平均仓位规模
- **成功率：** 盈利交易百分比（需要手动跟踪）

### 10.2 日志记录和分析

**CSV 日志文件（`matches_optimized.csv`）：**
- 所有检测和执行的交易
- 列：timestamp, block, token_id, usd_value, shares, price, direction, status, order_book_data, tx_hash, is_live
- 用于：性能分析、调试、审计跟踪

**控制台输出：**
- 实时执行状态
- 颜色编码的成交百分比
- 市场指标（TENNIS、SOCCER、实时状态）
- 最佳价格和订单簿数据

**分析建议：**
- 每周查看 CSV 日志
- 随时间跟踪指标（每周/每月）
- 比较不同鲸鱼的表现
- 识别模式（一天中的时间、市场类型等）

## 11. 策略调优指南

### 11.1 何时调整缩放比率

**增加缩放（更激进）：**
- 如果您有超额资本
- 如果鲸鱼持续盈利
- 如果成交率高（>90%）
- 如果您想要更高的敞口

**减少缩放（更保守）：**
- 如果资本有限
- 如果正在经历亏损
- 如果成交率低（<70%）
- 如果您想用较小金额测试

### 11.2 何时调整价格缓冲

**增加缓冲：**
- 如果成交率低
- 如果错过许多交易
- 如果鲸鱼交易是时间敏感的
- 在波动市场条件下

**减少缓冲：**
- 如果滑点高
- 如果成交率已经很好（>85%）
- 在稳定市场条件下
- 为了降低成本

### 11.3 何时调整风险保护设置

**更保守（更少交易）：**
- 增加 `CB_MIN_DEPTH_USD`（例如，$300-500）
- 增加 `CB_CONSECUTIVE_TRIGGER`（例如，3-4）
- 增加 `CB_TRIP_DURATION_SECS`（例如，300 秒）
- 减少 `CB_LARGE_TRADE_SHARES`（例如，1000.0）

**更激进（更多交易）：**
- 减少 `CB_MIN_DEPTH_USD`（例如，$100-150）
- 减少 `CB_CONSECUTIVE_TRIGGER`（例如，1）
- 减少 `CB_TRIP_DURATION_SECS`（例如，60 秒）
- 增加 `CB_LARGE_TRADE_SHARES`（例如，2000.0）

## 12. 未来增强（潜在）

### 12.1 多鲸鱼策略
- 同时复制多个鲸鱼
- 跨鲸鱼的投资组合分配
- 风险分散
- 性能比较

### 12.2 动态缩放
- 根据市场条件调整缩放
- 一天中的时间调整
- 基于波动性的缩放
- 基于性能的缩放

### 12.3 高级风险管理
- 每个市场的仓位限制
- 每日损失限制
- 胜率过滤器
- 相关性分析

### 12.4 机器学习集成
- 鲸鱼选择优化
- 交易预测
- 最佳进入/退出时机
- 模式识别

### 12.5 退出策略
- 自动获利了结
- 止损实施
- 基于时间的退出
- 追踪止损

### 12.6 分析仪表板
- 实时性能指标
- 可视化交易分析
- 历史性能图表
- 风险指标可视化

